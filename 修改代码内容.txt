dagre_fixed.js是基于 https://dagrejs.github.io/project/dagre/latest/dagre.js 进行的部分函数修改

（1）调整同层内的节点排序（锚定固定节点的坐标）

function order(g) {
  var maxRank = util.maxRank(g),
      downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), "inEdges"),
      upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), "outEdges");

  // Collect fixed node coordinates
  """
  在这段代码中，首先创建了一个空对象 fixedNodes，用于存储固定节点的坐标信息。然后，通过使
  用 g.nodes() 遍历图 g 中的所有节点。
  对于每个节点 v，代码检查 g.node(v).fixed 的值是否为 true，即该节点是否被标记为固定节点。
  如果节点是固定节点，那么将节点的坐标信息（x 和 y）保存为一个对象，结构类似 { x: xCoordinate, y: yCoordinate }，
  并将该对象存储在 fixedNodes 对象中，以节点名称 v 作为键。
  这样，当所有固定节点被遍历后，fixedNodes 对象将包含所有固定节点的坐标信息，这些信息将在布局优化过程中用来保持固定
  节点的位置不变。
  总之，fixedNodes 是一个对象，其中键是固定节点的名称，值是包含固定节点坐标信息的对象。这种数据结构的目的是在后续的
  布局优化中应用固定节点的坐标。
  """
  var fixedNodes = {};
  g.nodes().forEach(function(v) {
    if (g.node(v).fixed) {
      fixedNodes[v] = { x: g.node(v).x, y: g.node(v).y };
    }
  });
  """
  g.node(v).fixed 是一个用于表示节点是否是固定节点的属性。在使用这种属性之前，需要确保每个节点都有这个属性，
  并相应地设置它。
  示例：
  '''
  // 创建一个图对象
	var g = new dagre.graphlib.Graph();

	// 添加节点，并设置一些属性，比如 x 和 y 坐标，以及是否是固定节点
	g.setNode('node1', { x: 100, y: 100, fixed: false });
	g.setNode('node2', { x: 200, y: 150, fixed: true });
	g.setNode('node3', { x: 300, y: 200, fixed: false });

	// 添加边
	g.setEdge('node1', 'node2');
	g.setEdge('node2', 'node3');

  '''
  在上述示例中，每个节点通过 g.setNode 方法添加到图中，并且为每个节点都设置了一个 fixed 属性，以指示节点是否是固定
  节点。如果节点是固定节点，将 fixed 设置为 true，否则设置为 false。
  """

  var layering = initOrder(g);

  var bestCC = Number.POSITIVE_INFINITY,
      best;

  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

    layering = util.buildLayerMatrix(g);
    var cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = Object.assign({}, layering);
      bestCC = cc;
    }
  }

  // Apply best layout to non-fixed nodes
  g.nodes().forEach(function(v) {
    if (!g.node(v).fixed) {
      g.node(v).x = best[v].x;
      g.node(v).y = best[v].y;
    }
  });

  // Set fixed node coordinates
  Object.keys(fixedNodes).forEach(function(v) {
    g.node(v).x = fixedNodes[v].x;
    g.node(v).y = fixedNodes[v].y;
  });
}




（2）修改 positionY(g) 函数：

在 positionY 函数中，需要根据固定坐标节点的情况进行调整。在循环内，对于每个层次的节点，
需要检查节点是否是固定坐标节点，如果是，则将其 y 坐标设置为固定的 y 坐标，而不是根据
层次布局来计算。

function positionY(g) {
  var layering = util.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;

  layering.forEach(function(layer) {
    const maxHeight = layer.reduce((acc, v) => {
      const height = g.node(v).height;
      if (acc > height) {
        return acc;
      } else {
        return height;
      }
    }, 0);

    layer.forEach(v => {
      if (!g.node(v).fixed) { // Check if the node is not fixed
        g.node(v).y = prevY + maxHeight / 2;
      }
    });

    prevY += maxHeight + rankSep;
  });
}



（3）修改 positionX(g) 函数：

在 positionX 函数中，需要在 horizontalCompaction 部分考虑固定坐标节点的情况，以便为这
些节点分配正确的 x 坐标。可以将固定坐标节点的 x 坐标设置为固定值。
	
function positionX(g) {
  var layering = util.buildLayerMatrix(g);
  var conflicts = Object.assign(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering));

  var xss = {};
  var adjustedLayering;
  ["u", "d"].forEach(function(vert) {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
    ["l", "r"].forEach(function(horiz) {
      if (horiz === "r") {
        adjustedLayering = adjustedLayering.map(inner => {
          return Object.values(inner).reverse();
        });
      }

      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g, adjustedLayering,
        align.root, align.align, horiz === "r");

      // Set fixed node coordinates
      g.nodes().forEach(function(v) {
        if (g.node(v).fixed) {
          xs[v] = g.node(v).x;
        }
      });

      if (horiz === "r") {
        xs = util.mapValues(xs, x => -x);
      }
      xss[vert + horiz] = xs;
    });
  });

  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}


（4）修改 horizontalCompaction 函数

function horizontalCompaction(g, layering, root, align, reverseSep, fixedNodes) {
      // This portion of the algorithm differs from BK due to a number of problems.
      // Instead of their algorithm we construct a new block graph and do two
      // sweeps. The first sweep places blocks with the smallest possible
      // coordinates. The second sweep removes unused space by moving blocks to the
      // greatest coordinates without violating separation.
      var xs = {},
        blockG = buildBlockGraph(g, layering, root, reverseSep),
        borderType = reverseSep ? "borderLeft" : "borderRight";
    
      function iterate(setXsFunc, nextNodesFunc) {
        var stack = blockG.nodes();
        var elem = stack.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
    
          elem = stack.pop();
        }
      }
    
      // First pass, assign smallest coordinates
      function pass1(elem) {
        if (!fixedNodes.includes(elem)) { // Check if node is not a fixed node
          xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
            return Math.max(acc, xs[e.v] + blockG.edge(e));
          }, 0);
        }
      }
    
      // Second pass, assign greatest coordinates
      function pass2(elem) {
        if (!fixedNodes.includes(elem)) { // Check if node is not a fixed node
          var min = blockG.outEdges(elem).reduce(function(acc, e) {
            return Math.min(acc, xs[e.w] - blockG.edge(e));
          }, Number.POSITIVE_INFINITY);
    
          var node = g.node(elem);
          if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
            xs[elem] = Math.max(xs[elem], min);
          }
        }
      }
    
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
    
      // Assign x coordinates to all nodes
      Object.keys(align).forEach(v => xs[v] = xs[root[v]]);
    
      return xs;
    }



（4）修改 removeBorderNodes(g, fixedNodes)函数

在这个修改后的代码中，引入了一个名为 fixedNodes 的参数，它是一个数组，包含了想要保持坐标
固定的节点的标识符。在第一个 forEach 循环中，通过检查 fixedNodes.indexOf(v) === -1 来确保仅
对不在固定节点列表中的节点进行坐标计算和更新。这样，就可以在调用这个函数时指定哪些节点应该
保持固定。

function removeBorderNodes(g, fixedNodes) {
  g.nodes().forEach(v => {
    if (g.children(v).length && fixedNodes.indexOf(v) === -1) {
      var node = g.node(v);
      var t = g.node(node.borderTop);
      var b = g.node(node.borderBottom);
      var l = g.node(node.borderLeft[node.borderLeft.length - 1]);
      var r = g.node(node.borderRight[node.borderRight.length - 1]);

      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });

  g.nodes().forEach(v => {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}


（5）修改 translateGraph(g, fixedNodes)

引入一个名为 fixedNodes 的参数，它是一个数组，包含了希望保持坐标不变的节点的标识符。
在迭代节点和进行坐标计算的过程中，使用 fixedNodes.indexOf(v) === -1 条件，以跳过
那些在固定节点列表中的节点。这样，可以在调用函数时指定哪些节点应该保持固定，不受平移影响。

function translateGraph(g, fixedNodes) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;

  function getExtremes(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }

  g.nodes().forEach(v => {
    if (fixedNodes.indexOf(v) === -1) {
      getExtremes(g.node(v));
    }
  });

  g.edges().forEach(e => {
    var edge = g.edge(e);
    if (edge.hasOwnProperty("x")) {
      getExtremes(edge);
    }
  });

  minX -= marginX;
  minY -= marginY;

  g.nodes().forEach(v => {
    if (fixedNodes.indexOf(v) === -1) {
      var node = g.node(v);
      node.x -= minX;
      node.y -= minY;
    }
  });

  g.edges().forEach(e => {
    var edge = g.edge(e);
    edge.points.forEach(p => {
      p.x -= minX;
      p.y -= minY;
    });
    if (edge.hasOwnProperty("x")) {
      edge.x -= minX;
    }
    if (edge.hasOwnProperty("y")) {
      edge.y -= minY;
    }
  });

  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}

（6）修改 intersectRect 函数为 intersectCircle，以适配圆形节点，而非矩形节点

修改后的函数命名为 intersectCircle，它使用圆心坐标 (cx, cy) 和半径 r 来定义一个圆。然后，它计算给定点与圆心的偏移量 dx 和 dy。接着，使用 Math.atan2 函数计算出点与圆心之间的角度 angle。最后，通过三角函数计算得到交点的横纵坐标 sx 和 sy。
这样，修改后的 intersectCircle 函数可以根据给定的圆和点的相对位置，计算出点与圆的交点坐标。
需注意，circle 参数需要包含圆心坐标 (cx, cy) 和半径 radius。

function intersectCircle(circle, point) {
  var cx = circle.cx;
  var cy = circle.cy;
  var r = circle.radius;

  var dx = point.x - cx;
  var dy = point.y - cy;

  var angle = Math.atan2(dy, dx);
  var sx = cx + Math.cos(angle) * r;
  var sy = cy + Math.sin(angle) * r;

  return { x: sx, y: sy };
}


